#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout(set = 0, binding = 0) uniform GlobalBuffer {
    mat4 view;
    mat4 projection;
    mat4 transform;
    vec3 cameraPosition;
    uint currentLOD;
    uint totalClusters;
    float time;
} ubo;

layout(local_size_x = 1) in;

layout(triangles, max_vertices = 64, max_primitives = 124) out;

struct Meshlet {
    uint vertex_offset;
    uint triangle_offset;
    uint vertex_count;
    uint triangle_count;
};

struct Cluster{
    Meshlet meshlet;
    uint verticesOffset;
    uint trianglesOffset;
    uint childOffset;
    uint childCount;
};

struct Vertex {
    vec3 position;
    float texCoordX;
    vec3 normal;
    float texCoordY;
};

layout(set = 1, binding = 0) readonly buffer ClusterBuffer {
    Cluster clusters[];
} ;

layout(set = 1, binding = 1) readonly buffer MeshletVertexBuffer {
    uint meshlet_vertices[];
} ;

layout(set = 1, binding = 2) readonly buffer MeshletTriangleBuffer {
    uint8_t meshlet_triangles[]; // Need to unpack manually
} ;

layout(set = 1, binding = 3) readonly buffer VertexBuffer {
    Vertex vertices[];
};

layout(set = 1, binding = 4) readonly buffer LODOffsetBuffer{
    uint LODOffsets[];
};
layout(set = 1, binding = 5) readonly buffer childIndicesBuffer{
    uint childIndices[];
};


layout(location = 0) out VertexOutput
{
	vec3 position;
	vec3 normal;
	vec2 uv;
    vec3 color;
} vertexOut[];


struct Payload {
    vec2 instanceXY;
};

taskPayloadSharedEXT Payload payload;
// Built-in
void main() {

    uint LODOffset = LODOffsets[ubo.currentLOD];
    uint clusterIndex = gl_WorkGroupID.x;

    Cluster c = clusters[LODOffset + clusterIndex];
    Meshlet m = c.meshlet;

    SetMeshOutputsEXT(m.vertex_count, m.triangle_count);
        vec3 meshletColor = vec3(
        float((clusterIndex * 37) % 255) / 255.0,
        float((clusterIndex * 59) % 255) / 255.0,
        float((clusterIndex * 97) % 255) / 255.0
    );

    for (uint i = gl_LocalInvocationIndex; i < m.vertex_count; i += gl_WorkGroupSize.x) {
        uint index = meshlet_vertices[c.verticesOffset + m.vertex_offset + i];
        
        vec3 offset = vec3(payload.instanceXY, 0.0) * 0.5;
        vec4 worldPos = ubo.transform * vec4(vertices[index].position, 1.0) + vec4(vec3(offset),0.0);
        gl_MeshVerticesEXT[i].gl_Position = ubo.projection * ubo.view * worldPos;
    
        vertexOut[i].position = vertices[index].position;
        vertexOut[i].normal = vertices[index].normal;
        vertexOut[i].uv = vec2(vertices[index].texCoordX, vertices[index].texCoordY);
        vertexOut[i].color = meshletColor;
    }

    for (uint i = gl_LocalInvocationIndex; i < m.triangle_count; i += gl_WorkGroupSize.x) {
        uint offset = c.trianglesOffset + m.triangle_offset + i * 3;
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
            meshlet_triangles[offset], 
            meshlet_triangles[offset + 1], 
            meshlet_triangles[offset + 2]);
    }
}