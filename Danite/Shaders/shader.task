#version 460
#extension GL_EXT_mesh_shader : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

layout(local_size_x = 1) in;
struct Plane {
    vec3 normal;
    float dis;
};
struct Frustum {
    Plane topFace;
    Plane bottomFace;
    Plane rightFace;
    Plane leftFace;
    Plane farFace;
    Plane nearFace;
};
layout(set = 0, binding = 0) uniform GlobalBuffer {
    mat4 view;
    mat4 projection;
    mat4 transform;
    Frustum viewFrustum;
    vec3 cameraPosition;
    uint currentLOD;
    uint totalClusters;
    float time;
} ubo;

struct Meshlet {
    uint vertex_offset;
    uint triangle_offset;
    uint vertex_count;
    uint triangle_count;
};

struct Bound{
    vec3 center;
    float radius;

    float cone_apex[3];
    float cone_axis[3];
    float cone_cutoff;

    int8_t cone_axis_s8[3];
    int8_t cone_cutoff_s8;
};

struct Cluster{
    Meshlet meshlet;
    Bound bound;
    uint verticesOffset;
    uint trianglesOffset;
    uint childOffset;
    uint childCount;
};

struct Vertex {
    vec3 position;
    float texCoordX;
    vec3 normal;
    float texCoordY;
};

layout(set = 1, binding = 0) readonly buffer ClusterBuffer {
    Cluster clusters[];
} ;

layout(set = 1, binding = 1) readonly buffer MeshletVertexBuffer {
    uint meshlet_vertices[];
} ;

layout(set = 1, binding = 2) readonly buffer MeshletTriangleBuffer {
    uint8_t meshlet_triangles[]; 
} ;

layout(set = 1, binding = 3) readonly buffer VertexBuffer {
    Vertex vertices[];
};

layout(set = 1, binding = 4) readonly buffer LODOffsetBuffer{
    uint LODOffsets[];
};
layout(set = 1, binding = 5) readonly buffer childIndicesBuffer{
    uint childIndices[];
};

#define meshletCount 8879


struct Payload{
    uint clusterIndex;
    uint instanceIndex;
};
taskPayloadSharedEXT Payload payload;

bool isOnOrForwardPlane(vec3 center, float radius, Plane plane){
    return dot(plane.normal, center) - plane.dis > -radius;
}

bool frustumCulled(Bound bound){

    uint globalIndex = gl_WorkGroupID.x;
    
    uint instanceIndex = globalIndex / meshletCount;

    vec3 offset = 0.2 * vec3(float(instanceIndex % 10), 0.0, -float(instanceIndex) / 10.0);


    vec3 worldCenter = (ubo.transform * vec4(bound.center,1.f)).xyz + offset;

    vec3 globalScale = vec3(length(ubo.transform[0].xyz),
    length(ubo.transform[1].xyz),
    length(ubo.transform[2].xyz));
   
    float maxScale = max(max(globalScale.x, globalScale.y), globalScale.z);
    float scaledRadius = maxScale * bound.radius;
    

    return isOnOrForwardPlane(worldCenter, scaledRadius, ubo.viewFrustum.leftFace) &&
    isOnOrForwardPlane(worldCenter, scaledRadius, ubo.viewFrustum.rightFace) &&
    isOnOrForwardPlane(worldCenter, scaledRadius, ubo.viewFrustum.farFace) &&
    isOnOrForwardPlane(worldCenter, scaledRadius, ubo.viewFrustum.nearFace) &&
    isOnOrForwardPlane(worldCenter, scaledRadius, ubo.viewFrustum.topFace) &&
    isOnOrForwardPlane(worldCenter, scaledRadius, ubo.viewFrustum.bottomFace);
    
}

bool isVisible(Bound bound){
	return frustumCulled(bound);
}

void main(){
	
	
    uint globalIndex = gl_WorkGroupID.x;
    
    uint instanceIndex = globalIndex / meshletCount;
    uint clusterIndex = globalIndex % meshletCount;
	
    payload.instanceIndex = instanceIndex;
    payload.clusterIndex = clusterIndex;

    Cluster c = clusters[clusterIndex];

    if(isVisible(c.bound)){	EmitMeshTasksEXT(1,1,1);}
}